# SQL

## Nester Subqueries

- Subqueries can be nested inside other subqueries to an arbitrary depth, but this is rarely necessary.
- The innermost subquery is evaluated first, then the next innermost, and so on.

### Subqueries in the WHERE clause

#### Example

- FInd the courses offered in the Fall 2009 and in the Spring 2010 semesters (intersect example)

```sql
SELECT distinct course_id
FROM section
WHERE semester = 'Fall' AND year = 2009 AND course_id IN (
    SELECT course_id
    FROM section
    WHERE semester = 'Spring' AND year = 2010
);
```

- Find the total number of distinct students who took a course selection taught by instructor with id 10101

```sql
SELECT count(distinct student_id)
FROM takes
WHERE (course_id, sec_id) IN (
    SELECT (course_id, sec_id)
    FROM section
    WHERE instructor_id = 10101
);
```

###### Above query can be written in a better way, this is just an example of nested subqueries

- Find names of instructors with salary greater than that of some (at least one) instructor in the Biology department

```sql
 SELECT distinct name
 FROM instructor as T, instructor as S
 WHERE T.salary > S.salary AND S.dept_name = 'Biology';
```

- we can also write the above query as:

  - ```sql
    SELECT name
    FROM instructor
    WHERE salary > some (
        SELECT salary
        FROM instructor
        WHERE dept_name = 'Biology'
    );
    ```

### Defination of 'all' clause

- `F <comp> all` is true if and only if `F <comp>` every value in the set of values returned by the subquery.
- Where `<comp>` is any comparison operator.
- `F <comp> all` is equivalent to `not (F <comp> any)`

### Defination of 'exists' clause

- The `exists` clause is true if and only if the subquery returns at least one tuple.
- The `not exists` clause is true if and only if the subquery returns no tuples.
- The `exists` clause is true if `count (*) > 0` and `not exists` is true if `count (*) = 0`

#### Use of 'exists' clause

- Yet another way of specifying the query "Find all courses offered in the Fall 2009 and in the Spring 2010 semesters"

```sql
SELECT distinct course_id
from section as S
WHERE semester = 'Fall' AND year = 2009 AND exists (
    SELECT *
    FROM section as T
    WHERE semester = 'Spring' AND year = 2010 AND S.course_id = T.course_id
);
```

#### Use of 'not exists' clause

- Find all students who have taken all the courses offered in the Biology department

```sql
SELECT distinct student_id
FROM student as S
where not exists ( (
    SELECT course_id
    FROM course
    WHERE dept_name = 'Biology' )
    except (
        SELECT T.course_id
        FROM takes as T
        WHERE T.student_id = S.student_id
    ));
```

- First nested query lists all courses offered in Biology
- Second nested query lists all courses a particular student took

### Subqueries in the FROM clause

- Subqueries can also appear in the FROM clause of a query.
- Find the average instructors' salary of those departments whose average salary is greater than 42000

```sql
SELECT avg_salary, dept_name
FROM (
    SELECT avg(salary) as avg_salary, dept_name
    FROM instructor
    GROUP BY dept_name
) as T
WHERE avg_salary > 42000;
```

### Subqueries in the WITH clause

- The WITH clause allows us to define a temporary relation whose definition is available only to the query in which the WITH clause occurs.
- Find all departments with the maximum budget

```sql
with max_budget(value) as
    (select max(budget) from department)
select department.name
from department, max_budget
where department.budget = max_budget.value;
```

### Scalar Subqueries

- A scalar subquery is a subquery that returns exactly one value.
- List all departmentsalone with the number with the number of instructors in each department

```sql
select dept_name, (select count(*) from instructor where department.dept_name = instructor.dept_name) as num_instructors from department;
```

- Error will be thrown if the subquery returns more than one value.

### Deletion

- Delete all instructors
- ```sql
  delete from instructor;
  ```
- Delete all instructors from the Finance department
- ```sql
  delete from instructor where dept_name = 'Finance';
  ```
- Delete all instructors whose salary is less than the average salary of all instructors
  - ```sql
    delete from instructor where salary < (select avg(salary) from instructor);
    ```
  - As we delete tuples from the instructor relation, the average salary of the remaining instructors will change.
  - To avoid this problem, We compute the average salary of all instructors before we start deleting tuples from the instructor relation.

### Insertion

- Add a new tuple to course
- ```sql
  insert into course values ('CS-437', 'Database Systems', 'Comp. Sci.', 4);
  ```
- Add all instructors to the student relation with tot_cred set to $0$
  - ```sql
    insert into student
    select ID, name, dept_name, 0
      from instructor
    ```

### Update

- Increase the salary of all instructors in the Biology department by 10% and whose salary is above $100,000 by 5%
- ```sql
  update instructor
  set salary = salary * 1.05
  where dept_name = 'Biology' and salary > 100000;
  set salary = salary * 1.1
  where dept_name = 'Biology' and salary <= 100000;
  update instructor
  ```
- The order of the two update statements is important. The wrong order will result in some instructors getting a 10% raise and then a 5% raise on top of that.
- We can also use an else clause to avoid this problem
  - ```sql
    update instructor
    set salary = case
      when dept_name = 'Biology' and salary > 100000 then salary * 1.05
      when dept_name = 'Biology' and salary <= 100000 then salary * 1.1
      else salary
    end;
    ```
